#ifndef ELASTIX_AFFINE_TRANSFORMATION_HELPER
#define ELASTIX_AFFINE_TRANSFORMATION_HELPER

#include <pcl/geometry.h>
#include <pcl/misc/StringTokenizer.h>
#include <pcl/misc/FileStreamHelper.h>
#include <vnl/vnl_matrix_fixed.h>
#include <boost/algorithm/string.hpp>
#include <iostream>
#include <fstream>

namespace pcl
{
	namespace elastix
	{

		class AffineTransformationHelper
		{
		public:
			static pcl::geometry::AffineTransformation::Pointer LoadCompleteAffineTransformation(const std::string& file, bool ignore_fail=false)
			{
				std::string prev_file;
				pcl::geometry::AffineTransformation::Pointer result = LoadAffineTransformation(file, prev_file);
				while (!prev_file.empty()) {
					try {
						pcl::geometry::AffineTransformation::Pointer temp = LoadAffineTransformation(prev_file, prev_file);
						temp->addTransformation(result);
						result = temp;
					} catch (...) {
						if (!ignore_fail) throw;
						else prev_file.clear();
					}
				}
				return result;
			}

			static pcl::geometry::AffineTransformation::Pointer LoadAffineTransformation(const std::string& file)
			{
				std::string init_param_file;
				return LoadAffineTransformation(file, init_param_file);
			}

			static pcl::geometry::AffineTransformation::Pointer LoadAffineTransformation(const std::string& file, std::string& initial_transform_parameter_file)
			{
				auto is = pcl::FileStreamHelper::CreateIfstream(file);
				return LoadAffineTransformation(is, initial_transform_parameter_file);
			}

			static pcl::geometry::AffineTransformation::Pointer LoadAffineTransformation(std::istream& is, std::string& initial_transform_parameter_file) 
			{
				char buffer[1000];
				pcl::Point3D<double> translation(0,0,0), rotation_center(0,0,0);
				vnl_matrix_fixed<double, 3,3> transform_matrix;
				transform_matrix.set_identity();
				bool rotation_found = false,
					transform_found = false;
				while (is.good()) {
					buffer[0] = 0;
					is.getline(buffer, 1000);
					std::string message = buffer;
					if (message[message.length()-1]=='\n') message.resize(message.length()-1);
					boost::algorithm::trim(message);
					if (message.empty()) continue;
					if (message[0]=='(') message = message.substr(1);
					else continue;
					if (message[message.length()-1]==')') message.resize(message.length()-1);
					std::string header;
					std::vector<std::string> arguments;
					ProcessLine(message, header, arguments);
					//Processing the headers
					if (header==std::string("Transform")) {
						if (arguments[0]!=std::string("AffineTransform")) {
							pcl_ThrowException(pcl::Exception(), std::string("Input parameter file is of type ")+arguments[0]+" instead of type AffineTransform!");
						}
					} else if (header==std::string("InitialTransformParametersFileName")) {
						if (arguments[0]!=std::string("NoInitialTransform")) {
							initial_transform_parameter_file = arguments[0];
						} else initial_transform_parameter_file.clear();
					} else if (header==std::string("CenterOfRotationPoint")) { 
						for (int i=0; i<3; i++) rotation_center[i] = atof(arguments[i].c_str());
						rotation_found = true;
					} else if (header==std::string("TransformParameters")) {
						int count = 0;
						for (int r=0; r<3; r++) for (int c=0; c<3; c++) {
							transform_matrix(r,c) = atof(arguments[count].c_str());
							count++;
						}
						for (int i=0; i<3; i++) {
							translation[i] = atof(arguments[count].c_str());
							count++;
						}
						transform_found = true;
					}
				}
				
				if (!transform_found) {
					pcl_ThrowException(pcl::Exception(), "No transform found!");
				}
				if (!rotation_found) {
					std::cout << "Warning: Center of rotation not found. " << rotation_center << " assumed!";
				}

				auto trans = pcl::geometry::AffineTransformation::New();
				trans->addTranslation(-rotation_center);
				trans->addTransformation(transform_matrix);
				trans->addTranslation(rotation_center);
				trans->addTranslation(translation);
				return trans;
			}

			template <class ImagePointer>
			static void SaveAffineTransformation(const std::string& filename, const ImagePointer& image, const pcl::geometry::AffineTransformation::Pointer& trans, const std::string initial_transform_parameter_file="")
			{
				auto os = pcl::FileStreamHelper::CreateOfstream(filename);
				SaveAffineTransformation(os, image, trans, initial_transform_parameter_file);
				os.close();
			}

			template <class ImagePointer>
			static void SaveAffineTransformation(std::ostream& os, const ImagePointer& image, const pcl::geometry::AffineTransformation::Pointer& trans, const std::string initial_transform_parameter_file)
			{
				try {
					auto exception_obj = pcl::StreamExceptionHelper::GetStreamExceptionObject(os, std::ios_base::failbit | std::ios_base::badbit);
					os << "// Generated by AffineTransformGenerator class" << std::endl;
					os << "(Transform \"AffineTransform\")" << std::endl;
					os << "(NumberOfParameters 12)" << std::endl;
					os << "(TransformParameters";
					for (int r=0; r<3; r++) for (int c=0; c<3; c++) {
						os << " " << std::setprecision(10) << trans->getTransformation()(r,c);
					}
					for (int i=0; i<3; ++i) os << " " << std::setprecision(10) << trans->getTranslation()[i];
					os << ")" << std::endl;
					os << "(InitialTransformParametersFileName ";
					if (initial_transform_parameter_file.empty()) os << "\"NoInitialTransform\"";
					else os << "\"" << initial_transform_parameter_file << "\"";
					os << ")" << std::endl;
					os << "(HowToCombineTransforms \"Compose\")" << std::endl << std::endl;
					os << "// Image specific" << std::endl;
					os << "(FixedImageDimension 3)" << std::endl;
					os << "(MovingImageDimension 3)" << std::endl;
					os << "(FixedInternalImagePixelType \"float\")" << std::endl;
					os << "(MovingInternalImagePixelType \"float\")" << std::endl;
					
					auto adjusted_image = image->getAlias(pcl::Point3D<int>(0,0,0), true);
					os << "(Size";
					for (int i=0; i<3; ++i) os << " " << adjusted_image->getSize()[i];
					os << ")" << std::endl;

					os << "(Index 0 0 0)" << std::endl;

					os << "(Spacing";
					for (int i=0; i<3; ++i) os << " " << std::setprecision(10) << adjusted_image->getSpacing()[i];
					os << ")" << std::endl;

					os << "(Origin";
					for (int i=0; i<3; ++i) os << " " << std::setprecision(10) << adjusted_image->getOrigin()[i];
					os << ")" << std::endl;

					os << "(Direction 1.0000000000 0.0000000000 0.0000000000 0.0000000000 1.0000000000 0.0000000000 0.0000000000 0.0000000000 1.0000000000)" << std::endl;
					os << "(UseDirectionCosines \"false\")" << std::endl << std::endl;
					os << "// AdvancedAffineTransform specific" << std::endl;

					os << "(CenterOfRotationPoint 0.0000000000 0.0000000000 0.0000000000)" << std::endl << std::endl;

					os << "// ResampleInterpolator specific" << std::endl;
					os << "(ResampleInterpolator \"FinalBSplineInterpolator\")" << std::endl;
					os << "(FinalBSplineInterpolationOrder 3)" << std::endl << std::endl;
					os << "// Resampler specific" << std::endl;
					os << "(Resampler \"DefaultResampler\")" << std::endl;
					os << "(DefaultPixelValue 0.000000)" << std::endl;
					os << "(ResultImageFormat \"mhd\")" << std::endl;
					os << "(ResultImagePixelType \"short\")" << std::endl;
					os << "(CompressResultImage \"false\")" << std::endl;
				} catch (const std::ios_base::failure& e) {
					pcl_ThrowException(pcl::Exception(), e.what());
				}
			}

		protected:
			static void ProcessLine(std::string& buffer, std::string& header, std::vector<std::string>& arguments) 
			{
				std::string token;
				pcl::misc::StringTokenizer tokenizer(buffer.c_str());
				bool is_header = true;
				for (tokenizer.begin(' '); !tokenizer.end(); tokenizer.next(' ')) {
					std::string token = tokenizer.getToken();
					boost::algorithm::trim_if(token, boost::is_any_of("\""));
					if (is_header) {
						header = token;
						is_header = false;
					} else arguments.push_back(token);
				}
			}
		};

	}
}

#endif